# -*- coding: utf-8 -*-
"""Computational_drug_discovery_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xh7f6em3-ufR6gg1qSgW4QweLWxkgapa
"""

! pip install chembl_webresource_client

import pandas as pd
from chembl_webresource_client.new_client import new_client

"""## **Search for Target protein**"""

target = new_client.target
target_query = target.search('coronavirus')
targets = pd.DataFrame.from_dict(target_query)
targets

selected_target = targets.target_chembl_id[8]
selected_target

"""# **Replicase polyprotein 1ab (Severe acute respiratory syndrome-related coronavirus)**
Multifunctional protein involved in the transcription and replication of viral RNAs. Contains the proteinases responsible for the cleavages of the polyprotein.

Inhibits host translation by interacting with the 40S ribosomal subunit. The nsp1-40S ribosome complex further induces an endonucleolytic cleavage near the 5'UTR of host mRNAs, targeting them for degradation. Viral mRNAs are not susceptible to nsp1-mediated endonucleolytic RNA cleavage thanks to the presence of a 5'-end leader sequence and are therefore protected from degradation. By suppressing host gene expression, nsp1 facilitates efficient viral gene expression in infected cells and evasion from host immune response (PMID: 23035226).

Here, we will retrieve only bioactivity data for *coronavirus 3C-like proteinase* (CHEMBL5118) that are reported as IC$_{50}$ values in nM (nanomolar) unit.
"""

activity= new_client.activity
res = activity.filter(target_chembl_id=selected_target).filter(standard_type="IC50")

df = pd.DataFrame.from_dict(res)

df.head(2)

df.to_csv('bioactivity_data_raw.csv',index=False)

df2 = df[df.standard_value.notna()]
df2

"""## **Data pre-processing of the bioactivity data**

### **Labeling compounds as either being active, inactive or intermediate**
The bioactivity data is in the IC50 unit. Compounds having values of less than 1000 nM will be considered to be **active** while those greater than 10,000 nM will be considered to be **inactive**. As for those values in between 1,000 and 10,000 nM will be referred to as **intermediate**.
"""

bioactivity_class= []
for i in df2.standard_value:
  if float(i) >= 10000:
    bioactivity_class.append("inactive")
  elif float(i) <= 1000:
    bioactivity_class.append("active")
  else:
    bioactivity_class.append("intermediate")

"""### **Combine the 3 columns (molecule_chembl_id,canonical_smiles,standard_value) and bioactivity_class into a DataFrame**"""

df2.columns

selection = ['molecule_chembl_id','canonical_smiles','standard_value']
df3 = df2[selection]

df3

bioactivity_class = pd.Series(bioactivity_class, name='bioactivity_class')
df4 = pd.concat([df3,bioactivity_class], axis=1)

df4 = df4[df.standard_value.notna()]
df4

df4.to_csv('bioactivity_data_preprocessed.csv',index=False)
! ls -l

#copying it to google drive
! cp bioactivity_data_preprocessed.csv "/content/gdrive/My Drive/Colab Notebooks/Computational drug discovery"
! ls "/content/gdrive/My Drive/Colab Notebooks/Computational drug discovery"

"""# **PART 2**"""

! wget https://repo.anaconda.com/miniconda/Miniconda3-py37_4.8.2-Linux-x86_64.sh
! chmod +x Miniconda3-py37_4.8.2-Linux-x86_64.sh
! bash ./Miniconda3-py37_4.8.2-Linux-x86_64.sh -b -f -p /usr/local
! conda install -c rdkit rdkit -y
import sys
sys.path.append('/usr/local/lib/python3.7/site-packages/')

import pandas as pd
df = pd.read_csv('bioactivity_data_preprocessed.csv')

import numpy as np
!pip install rdkit

from rdkit import Chem
from rdkit.Chem import Descriptors, Lipinski

# Inspired by: https://codeocean.com/explore/capsules?query=tag:data-curation

def lipinski(smiles, verbose=False):

    moldata= []
    for elem in smiles:
        mol=Chem.MolFromSmiles(elem)
        moldata.append(mol)

    baseData= np.arange(1,1)
    i=0
    for mol in moldata:

        desc_MolWt = Descriptors.MolWt(mol)
        desc_MolLogP = Descriptors.MolLogP(mol)
        desc_NumHDonors = Lipinski.NumHDonors(mol)
        desc_NumHAcceptors = Lipinski.NumHAcceptors(mol)

        row = np.array([desc_MolWt,
                        desc_MolLogP,
                        desc_NumHDonors,
                        desc_NumHAcceptors])

        if(i==0):
            baseData=row
        else:
            baseData=np.vstack([baseData, row])
        i=i+1

    columnNames=["MW","LogP","NumHDonors","NumHAcceptors"]
    descriptors = pd.DataFrame(data=baseData,columns=columnNames)

    return descriptors

df_lipinski= lipinski(df.canonical_smiles)
df_lipinski

"""# **Combining DataFrames**"""

df_combined = pd.concat([df,df_lipinski], axis= 1)
df_combined

"""### **Convert IC50 to pIC50**
To allow **IC50** data to be more uniformly distributed, we will convert **IC50** to the negative logarithmic scale which is essentially **-log10(IC50)**.

This custom function pIC50() will accept a DataFrame as input and will:
* Take the IC50 values from the ``standard_value`` column and converts it from nM to M by multiplying the value by 10$^{-9}$
* Take the molar value and apply -log10
* Delete the ``standard_value`` column and create a new ``pIC50`` column
"""

import numpy as np

def pIC50(input):
    pIC50 = []

    for i in input['standard_value_norm']:
        molar = i*(10**-9) # Converts nM to M
        pIC50.append(-np.log10(molar))

    input['pIC50'] = pIC50
    x = input.drop('standard_value_norm', 1)

    return x

df_combined.standard_value.describe()

-np.log10( (10**-9)* 100000000 )

-np.log10( (10**-9)* 10000000000 )

def norm_value(input):
    norm = []

    for i in input['standard_value']:
        if i > 100000000:
          i = 100000000
        norm.append(i)

    input['standard_value_norm'] = norm
    x = input.drop('standard_value', 1)

    return x

df_norm = norm_value(df_combined)
df_norm

df_final = pIC50(df_norm)
df_final

df_final.pIC50.describe()

"""### **Removing the 'intermediate' bioactivity class**

---


Here, we will be removing the ``intermediate`` class from our data set.
"""

df_2class = df_final[df_final.bioactivity_class != 'intermediate']
df_2class

"""## **Exploratory Data Analysis**"""

import seaborn as sns
sns.set(style = 'ticks')
import matplotlib.pyplot as plt

plt.figure(figsize=(5.5,5.5))

sns.countplot(x='bioactivity_class', data= df_2class, edgecolor= 'black')

plt.xlabel('Bioactivity class', fontsize = 14, fontweight='bold')
plt.ylabel('Frequency', fontsize = 14, fontweight='bold')

plt.savefig('plot_biactivity_class.pdf')

"""# **Scatter plot of MWolecular Weight versus LogP**
It can be seen that the 2 bioactivity classes are spanning similar chemical spaces as evident by the scatter plot of MW vs LogP.
"""

plt.figure(figsize=(5.5,5.5))
#sns.scatterplot(x='MW', y='LogP', data=df_2class, hue='bioactivity_class', size='pIC50', edgecolor='black', alpha=0.7)

sns.scatterplot(x='MW', y= 'LogP', data = df_2class, hue= 'bioactivity_class', size= 'pIC50', edgecolor= 'black', alpha = 0.7)

plt.xlabel('Molecular weight', fontsize= 14, fontweight= 'bold')
plt.ylabel('LogP', fontsize= 14, fontweight= 'bold')
plt.legend(bbox_to_anchor=(1.05,1), loc=2, borderaxespad=0)

"""# **Box Plot pIC50 value**"""

plt.figure(figsize=(5.5,5.5))

sns.boxplot(x= 'bioactivity_class', y= 'pIC50', data= df_2class)

plt.xlabel('Bioactivity class', fontsize= 14, fontweight= 'bold')
plt.xlabel('Bioactivity class', fontsize= 14, fontweight= 'bold')

plt.savefig('plot_IC50.pdf')

"""**Statistical analysis | Mann-Whitney U Test**


"""

def mannwhitney(descriptor, verbose=False):
  # https://machinelearningmastery.com/nonparametric-statistical-significance-tests-in-python/
  from numpy.random import seed
  from numpy.random import randn
  from scipy.stats import mannwhitneyu

# seed the random number generator
  seed(1)

# actives and inactives
  selection = [descriptor, 'bioactivity_class']
  df = df_2class[selection]
  active = df[df.bioactivity_class == 'active']
  active = active[descriptor]

  selection = [descriptor, 'bioactivity_class']
  df = df_2class[selection]
  inactive = df[df.bioactivity_class == 'inactive']
  inactive = inactive[descriptor]

# compare samples
  stat, p = mannwhitneyu(active, inactive)
  #print('Statistics=%.3f, p=%.3f' % (stat, p))

# interpret
  alpha = 0.05
  if p > alpha:
    interpretation = 'Same distribution (fail to reject H0)'
  else:
    interpretation = 'Different distribution (reject H0)'

  results = pd.DataFrame({'Descriptor':descriptor,
                          'Statistics':stat,
                          'p':p,
                          'alpha':alpha,
                          'Interpretation':interpretation}, index=[0])
  filename = 'mannwhitneyu_' + descriptor + '.csv'
  results.to_csv(filename)
  return results

mannwhitney('pIC50')

plt.figure(figsize=(5.5,5.5))

sns.boxplot(x= 'bioactivity_class', y= 'MW', data= df_2class)

plt.xlabel('Bioactivity class', fontsize=14, fontweight='bold')
plt.ylabel('MW', fontsize=14, fontweight='bold')

plt.savefig('plot_MW.pdf')

mannwhitney('MW')

"""#### **LogP**"""

plt.figure(figsize=(5.5, 5.5))

sns.boxplot(x = 'bioactivity_class', y = 'LogP', data = df_2class)

plt.xlabel('Bioactivity class', fontsize=14, fontweight='bold')
plt.ylabel('LogP', fontsize=14, fontweight='bold')

plt.savefig('plot_LogP.pdf')

"""**Statistical analysis | Mann-Whitney U Test**"""

mannwhitney('LogP')

"""#### **NumHDonors**"""

plt.figure(figsize=(5.5, 5.5))

sns.boxplot(x = 'bioactivity_class', y = 'NumHDonors', data = df_2class)

plt.xlabel('Bioactivity class', fontsize=14, fontweight='bold')
plt.ylabel('NumHDonors', fontsize=14, fontweight='bold')

plt.savefig('plot_NumHDonors.pdf')

"""**Statistical analysis | Mann-Whitney U Test**"""

mannwhitney('NumHDonors')

"""#### **NumHAcceptors**"""

plt.figure(figsize=(5.5, 5.5))

sns.boxplot(x = 'bioactivity_class', y = 'NumHAcceptors', data = df_2class)

plt.xlabel('Bioactivity class', fontsize=14, fontweight='bold')
plt.ylabel('NumHAcceptors', fontsize=14, fontweight='bold')

plt.savefig('plot_NumHAcceptors.pdf')

mannwhitney('NumHAcceptors')

"""#### **Interpretation of Statistical Results**

##### **Box Plots**

###### **pIC50 values**

Taking a look at pIC50 values, the **actives** and **inactives** displayed ***statistically significant difference***, which is to be expected since threshold values (``IC50 < 1,000 nM = Actives while IC50 > 10,000 nM = Inactives``, corresponding to ``pIC50 > 6 = Actives and pIC50 < 5 = Inactives``) were used to define actives and inactives.

###### **Lipinski's descriptors**

All the 4 Lipinski's descriptors (MW, LogP, NumHDonors and NumHAcceptors) shows ***statistically significant difference*** between **actives** and **inactives**.

## **Zip files**
"""

! zip -r results.zip . -i *.csv *.pdf